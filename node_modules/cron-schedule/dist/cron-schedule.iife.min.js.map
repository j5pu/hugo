{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils.ts", "../src/schedulers/interval-based.ts", "../src/schedulers/timer-based.ts", "../src/cron.ts", "../src/cron-parser.ts"],
  "sourcesContent": ["export * from './schedulers/interval-based'\nexport * from './schedulers/timer-based'\nexport * from './cron-parser'\nexport * from './cron'\nexport * from './utils'\n", "export const TIMEOUT_MAX = 2147483647 // 2^31-1\n\nexport interface ITimerHandle {\n  timeoutId?: ReturnType<typeof setTimeout>\n}\n\n/**\n * Creates a new timeout, which can exceed the max timeout limit of 2^31-1.\n * Since multiple timeouts are used internally, the timeoutId used to clear the timeout\n * is returned as a handle (object) and changes whenever the max timeout limit is exceeded.\n * The handle parameter can be ignored, it is used internally for updating the timeoutId\n * in the handle after creating the next timeout.\n */\nexport function longTimeout(\n  fn: () => void,\n  timeout: number,\n  handle?: ITimerHandle\n): ITimerHandle {\n  let after = 0\n\n  if (timeout > TIMEOUT_MAX) {\n    after = timeout - TIMEOUT_MAX\n    timeout = TIMEOUT_MAX\n  }\n\n  handle ??= {\n    timeoutId: undefined,\n  }\n\n  handle.timeoutId = setTimeout(() => {\n    if (after > 0) {\n      longTimeout(fn, after, handle)\n    } else {\n      fn()\n    }\n  }, timeout)\n\n  return handle\n}\n\n/* Extracts second, minute, hour, date, month and the weekday from a date. */\nexport function extractDateElements(\n  date: Date\n): {\n  second: number\n  minute: number\n  hour: number\n  day: number\n  month: number\n  weekday: number\n  year: number\n} {\n  return {\n    second: date.getSeconds(),\n    minute: date.getMinutes(),\n    hour: date.getHours(),\n    day: date.getDate(),\n    month: date.getMonth(),\n    weekday: date.getDay(),\n    year: date.getFullYear(),\n  }\n}\n\n/* Gets the amount of days in the given month (indexed by 0) of the given year. */\nexport function getDaysInMonth(year: number, month: number): number {\n  return new Date(year, month + 1, 0).getDate()\n}\n\n/* Gets the amount of days from weekday1 to weekday2. */\nexport function getDaysBetweenWeekdays(\n  weekday1: number,\n  weekday2: number\n): number {\n  if (weekday1 <= weekday2) {\n    return weekday2 - weekday1\n  }\n\n  return 6 - weekday1 + weekday2 + 1\n}\n\nexport function wrapFunction(\n  fn: () => unknown,\n  errorHandler?: (err: unknown) => unknown\n) {\n  return () => {\n    try {\n      const res = fn()\n\n      if (res instanceof Promise) {\n        res.catch((err) => {\n          if (errorHandler) {\n            errorHandler(err)\n          }\n        })\n      }\n    } catch (err) {\n      if (errorHandler) {\n        errorHandler(err)\n      }\n    }\n  }\n}\n", "import type { Cron } from '../cron'\nimport { wrapFunction } from '../utils'\n\ninterface ITaskWrapper {\n  id: number\n  cron: Cron\n  nextExecution: Date\n  task: () => unknown\n  isOneTimeTask: boolean\n  errorHandler?: (err: unknown) => unknown\n}\n\n/**\n * A cron scheduler that is based on a single interval.\n * Every interval, it checks whether a registered cron task\n * was due during the last interval and executes it.\n * This scheduler might be more performant depending on the use case,\n * because it only creates a single interval for all scheduled crons,\n * however depending on the interval and crons, tasks might be executed\n * with a delay.\n */\nexport class IntervalBasedCronScheduler {\n  #interval: number\n  #intervalId?: ReturnType<typeof setInterval>\n  #tasks: ITaskWrapper[] = []\n  #nextTaskId = 1\n\n  /**\n   * Creates and starts a new scheduler with the given interval.\n   */\n  public constructor(interval: number) {\n    this.#interval = interval\n    this.start()\n  }\n\n  /* Starts the scheduler. */\n  public start(): void {\n    if (this.#intervalId !== undefined) {\n      throw new Error('Scheduler already started.')\n    }\n\n    this.#intervalId = setInterval(this.processTasks.bind(this), this.#interval)\n  }\n\n  /* Ensures the scheduler is stopped. */\n  public stop(): void {\n    if (this.#intervalId) {\n      clearInterval(this.#intervalId)\n      this.#intervalId = undefined\n    }\n  }\n\n  /* Inserts a task in the tasks array at the right position sorted by nextExecution time. */\n  private insertTask(newTask: ITaskWrapper) {\n    const index = this.#tasks.findIndex(\n      (task) => task.nextExecution.getTime() > newTask.nextExecution.getTime()\n    )\n\n    this.#tasks.splice(index, 0, newTask)\n  }\n\n  /* Registers a new task. */\n  public registerTask(\n    cron: Cron,\n    task: () => unknown,\n    opts?: {\n      isOneTimeTask: boolean\n      errorHandler?: (err: unknown) => unknown\n    }\n  ): number {\n    const id = this.#nextTaskId\n\n    this.insertTask({\n      id,\n      cron,\n      nextExecution: cron.getNextDate(),\n      task,\n      isOneTimeTask: opts?.isOneTimeTask ?? false,\n      errorHandler: opts?.errorHandler,\n    })\n\n    this.#nextTaskId += 1\n    return id\n  }\n\n  /** Unregisters a task, causing it to no longer be executed. */\n  public unregisterTask(id: number): void {\n    const taskIndex = this.#tasks.findIndex((task) => task.id === id)\n    if (taskIndex === -1) throw new Error('Task not found.')\n    this.#tasks.splice(taskIndex, 1)\n  }\n\n  /* Sorts the tasks array based on the next execution time so that the next task is first in the array. */\n  private sortTasks(): void {\n    this.#tasks.sort((a, b) => {\n      return a.nextExecution.getTime() - b.nextExecution.getTime()\n    })\n  }\n\n  private processTasks(): void {\n    const now = Date.now()\n    let taskExecuted = false\n    let oneTimeTaskExecuted = false\n\n    // Execute all due tasks and update nextExecution for non-one-time tasks.\n    for (let i = 0; i < this.#tasks.length; i += 1) {\n      const task = this.#tasks[i]\n\n      if (task.nextExecution.getTime() <= now) {\n        wrapFunction(task.task, task.errorHandler)()\n\n        if (!task.isOneTimeTask) {\n          taskExecuted = true\n          task.nextExecution = task.cron.getNextDate()\n        } else {\n          oneTimeTaskExecuted = true\n        }\n      } else {\n        break\n      }\n    }\n\n    if (oneTimeTaskExecuted) {\n      // Remove one time tasks.\n      this.#tasks = this.#tasks.filter(\n        (task) => task.nextExecution.getTime() > now\n      )\n    }\n\n    // When at least one nextExecution time got updated (at least one non-one-time-task ran),\n    // we need to resort the tasks based on nextExecution.\n    if (taskExecuted) {\n      this.sortTasks()\n    }\n  }\n}\n", "import type { Cron } from '../cron'\nimport { ITimerHandle, longTimeout, wrapFunction } from '../utils'\n\n/**\n * A cron scheduler that is based on timers.\n * It will create one timer for every scheduled cron.\n * When the node timeout limit of ~24 days would be exceeded,\n * it uses multiple consecutive timeouts.\n */\nexport class TimerBasedCronScheduler {\n  /**\n   * Creates a timeout, which will fire the given task on the next cron date.\n   * Returns a handle which can be used to clear the timeout using clearTimeoutOrInterval.\n   */\n  public static setTimeout(\n    cron: Cron,\n    task: () => unknown,\n    opts?: { errorHandler?: (err: unknown) => unknown }\n  ): ITimerHandle {\n    const nextSchedule = cron.getNextDate()\n    const timeout = nextSchedule.getTime() - Date.now()\n\n    return longTimeout(wrapFunction(task, opts?.errorHandler), timeout)\n  }\n\n  /**\n   * Creates an interval, which will fire the given task on every future cron date.\n   * Returns a handle which can be used to clear the interval using clearTimeoutOrInterval.\n   */\n  public static setInterval(\n    cron: Cron,\n    task: () => unknown,\n    opts?: { errorHandler?: (err: unknown) => unknown; handle?: ITimerHandle }\n  ): ITimerHandle {\n    const handle = opts?.handle ?? { timeoutId: undefined }\n\n    const { timeoutId } = this.setTimeout(cron, () => {\n      wrapFunction(task, opts?.errorHandler)()\n      this.setInterval(cron, task, { ...opts, handle })\n    })\n\n    handle.timeoutId = timeoutId\n\n    return handle\n  }\n\n  /** Clears a timeout or interval, making sure that the function will no longer execute. */\n  public static clearTimeoutOrInterval(handle: ITimerHandle): void {\n    if (handle.timeoutId) {\n      clearTimeout(handle.timeoutId)\n    }\n  }\n}\n", "import {\n  extractDateElements,\n  getDaysBetweenWeekdays,\n  getDaysInMonth,\n} from './utils'\n\n/**\n * An object with contains for each element of a date, which values are allowed.\n * Everything starting at 0, except for days.\n */\nexport interface ICronDefinition {\n  readonly seconds: Set<number>\n  readonly minutes: Set<number>\n  readonly hours: Set<number>\n  readonly days: Set<number>\n  readonly months: Set<number>\n  readonly weekdays: Set<number>\n}\n\nexport class Cron {\n  // Everything starting at 0, except for days.\n  public readonly seconds: ReadonlyArray<number>\n  public readonly minutes: ReadonlyArray<number>\n  public readonly hours: ReadonlyArray<number>\n  public readonly days: ReadonlyArray<number>\n  public readonly months: ReadonlyArray<number>\n  public readonly weekdays: ReadonlyArray<number>\n\n  public readonly reversed: {\n    seconds: ReadonlyArray<number>\n    minutes: ReadonlyArray<number>\n    hours: ReadonlyArray<number>\n    days: ReadonlyArray<number>\n    months: ReadonlyArray<number>\n    weekdays: ReadonlyArray<number>\n  }\n\n  public constructor({\n    seconds,\n    minutes,\n    hours,\n    days,\n    months,\n    weekdays,\n  }: ICronDefinition) {\n    // Validate that there are values provided.\n    if (!seconds || seconds.size === 0)\n      throw new Error('There must be at least one allowed second.')\n    if (!minutes || minutes.size === 0)\n      throw new Error('There must be at least one allowed minute.')\n    if (!hours || hours.size === 0)\n      throw new Error('There must be at least one allowed hour.')\n    if (!months || months.size === 0)\n      throw new Error('There must be at least one allowed month.')\n    if ((!weekdays || weekdays.size === 0) && (!days || days.size === 0))\n      throw new Error('There must be at least one allowed day or weekday.')\n\n    // Convert set to array and sort in ascending order.\n    this.seconds = Array.from(seconds).sort((a, b) => a - b)\n    this.minutes = Array.from(minutes).sort((a, b) => a - b)\n    this.hours = Array.from(hours).sort((a, b) => a - b)\n    this.days = Array.from(days).sort((a, b) => a - b)\n    this.months = Array.from(months).sort((a, b) => a - b)\n    this.weekdays = Array.from(weekdays).sort((a, b) => a - b)\n\n    // Validate that all values are integers within the constraint.\n    const validateData = (\n      name: string,\n      data: ReadonlyArray<number>,\n      constraint: { min: number; max: number }\n    ) => {\n      if (\n        data.some(\n          (x) =>\n            typeof x !== 'number' ||\n            x % 1 !== 0 ||\n            x < constraint.min ||\n            x > constraint.max\n        )\n      ) {\n        throw new Error(\n          `${name} must only consist of integers which are within the range of ${constraint.min} and ${constraint.max}`\n        )\n      }\n    }\n\n    validateData('seconds', this.seconds, { min: 0, max: 59 })\n    validateData('minutes', this.minutes, { min: 0, max: 59 })\n    validateData('hours', this.hours, { min: 0, max: 23 })\n    validateData('days', this.days, { min: 1, max: 31 })\n    validateData('months', this.months, { min: 0, max: 11 })\n    validateData('weekdays', this.weekdays, { min: 0, max: 6 })\n\n    // For each element, store a reversed copy in the reversed attribute for finding prev dates.\n    this.reversed = {\n      seconds: this.seconds.map((x) => x).reverse(),\n      minutes: this.minutes.map((x) => x).reverse(),\n      hours: this.hours.map((x) => x).reverse(),\n      days: this.days.map((x) => x).reverse(),\n      months: this.months.map((x) => x).reverse(),\n      weekdays: this.weekdays.map((x) => x).reverse(),\n    }\n  }\n\n  /**\n   * Find the next or previous hour, starting from the given start hour that matches the hour constraint.\n   * startHour itself might also be allowed.\n   */\n  private findAllowedHour(\n    dir: 'next' | 'prev',\n    startHour: number\n  ): number | undefined {\n    return dir === 'next'\n      ? this.hours.find((x) => x >= startHour)\n      : this.reversed.hours.find((x) => x <= startHour)\n  }\n\n  /**\n   * Find the next or previous minute, starting from the given start minute that matches the minute constraint.\n   * startMinute itself might also be allowed.\n   */\n  private findAllowedMinute(\n    dir: 'next' | 'prev',\n    startMinute: number\n  ): number | undefined {\n    return dir === 'next'\n      ? this.minutes.find((x) => x >= startMinute)\n      : this.reversed.minutes.find((x) => x <= startMinute)\n  }\n\n  /**\n   * Find the next or previous second, starting from the given start second that matches the second constraint.\n   * startSecond itself IS NOT allowed.\n   */\n  private findAllowedSecond(\n    dir: 'next' | 'prev',\n    startSecond: number\n  ): number | undefined {\n    return dir === 'next'\n      ? this.seconds.find((x) => x > startSecond)\n      : this.reversed.seconds.find((x) => x < startSecond)\n  }\n\n  /**\n   * Find the next or previous time, starting from the given start time that matches the hour, minute\n   * and second constraints. startTime itself might also be allowed.\n   */\n  private findAllowedTime(\n    dir: 'next' | 'prev',\n    startTime: { hour: number; minute: number; second: number }\n  ): { hour: number; minute: number; second: number } | undefined {\n    // Try to find an allowed hour.\n    let hour = this.findAllowedHour(dir, startTime.hour)\n    if (hour !== undefined) {\n      if (hour === startTime.hour) {\n        // We found an hour that is the start hour. Try to find an allowed minute.\n        let minute = this.findAllowedMinute(dir, startTime.minute)\n        if (minute !== undefined) {\n          if (minute === startTime.minute) {\n            // We found a minute that is the start minute. Try to find an allowed second.\n            const second = this.findAllowedSecond(dir, startTime.second)\n            if (second !== undefined) {\n              // We found a second within the start hour and minute.\n              return { hour, minute, second }\n            } else {\n              // We did not find a valid second within the start minute. Try to find another minute.\n              minute = this.findAllowedMinute(\n                dir,\n                dir === 'next' ? startTime.minute + 1 : startTime.minute - 1\n              )\n              if (minute !== undefined) {\n                // We found a minute which is not the start minute. Return that minute together with the hour and the first / last allowed second.\n                return {\n                  hour,\n                  minute,\n                  second:\n                    dir === 'next' ? this.seconds[0] : this.reversed.seconds[0],\n                }\n              }\n            }\n          } else {\n            // We found a minute which is not the start minute. Return that minute together with the hour and the first / last allowed second.\n            return {\n              hour,\n              minute,\n              second:\n                dir === 'next' ? this.seconds[0] : this.reversed.seconds[0],\n            }\n          }\n        }\n\n        // We did not find an allowed minute / second combination inside the start hour. Try to find the next / previous allowed hour.\n        hour = this.findAllowedHour(\n          dir,\n          dir === 'next' ? startTime.hour + 1 : startTime.hour - 1\n        )\n        if (hour !== undefined) {\n          // We found an allowed hour which is not the start hour. Return that hour together with the first / last allowed minutes / seconds.\n          return {\n            hour,\n            minute: dir === 'next' ? this.minutes[0] : this.reversed.minutes[0],\n            second: dir === 'next' ? this.seconds[0] : this.reversed.seconds[0],\n          }\n        }\n      } else {\n        // We found an allowed hour which is not the start hour. Return that hour together with the first / last allowed minutes / seconds.\n        return {\n          hour,\n          minute: dir === 'next' ? this.minutes[0] : this.reversed.minutes[0],\n          second: dir === 'next' ? this.seconds[0] : this.reversed.seconds[0],\n        }\n      }\n    }\n\n    // No allowed time found.\n    return undefined\n  }\n\n  /**\n   * Find the next or previous day in the given month, starting from the given startDay\n   * that matches either the day or the weekday constraint. startDay itself might also be allowed.\n   */\n  private findAllowedDayInMonth(\n    dir: 'next' | 'prev',\n    year: number,\n    month: number,\n    startDay: number\n  ): number | undefined {\n    if (startDay < 1) throw new Error('startDay must not be smaller than 1.')\n    // If only days are restricted: allow day based on day constraint only..\n    // If only weekdays are restricted: allow day based on weekday constraint only.\n    // If both are restricted: allow day based on both day and weekday constraint. pick day that is closer to startDay.\n    // If none are restricted: return the day closest to startDay (respecting dir) that is allowed (or startDay itself).\n\n    const daysInMonth = getDaysInMonth(year, month)\n    const daysRestricted = this.days.length !== 31\n    const weekdaysRestricted = this.weekdays.length !== 7\n\n    if (!daysRestricted && !weekdaysRestricted) {\n      if (startDay > daysInMonth) {\n        return dir === 'next' ? undefined : daysInMonth\n      }\n\n      return startDay\n    }\n\n    // Try to find a day based on the days constraint.\n    let allowedDayByDays\n    if (daysRestricted) {\n      allowedDayByDays =\n        dir === 'next'\n          ? this.days.find((x) => x >= startDay)\n          : this.reversed.days.find((x) => x <= startDay)\n\n      // Make sure the day does not exceed the amount of days in month.\n      if (allowedDayByDays !== undefined && allowedDayByDays > daysInMonth) {\n        allowedDayByDays = undefined\n      }\n    }\n\n    // Try to find a day based on the weekday constraint.\n    let allowedDayByWeekdays\n    if (weekdaysRestricted) {\n      const startWeekday = new Date(year, month, startDay).getDay()\n      const nearestAllowedWeekday =\n        dir === 'next'\n          ? this.weekdays.find((x) => x >= startWeekday) ?? this.weekdays[0]\n          : this.reversed.weekdays.find((x) => x <= startWeekday) ??\n            this.reversed.weekdays[0]\n\n      if (nearestAllowedWeekday !== undefined) {\n        const daysBetweenWeekdays =\n          dir === 'next'\n            ? getDaysBetweenWeekdays(startWeekday, nearestAllowedWeekday)\n            : getDaysBetweenWeekdays(nearestAllowedWeekday, startWeekday)\n\n        allowedDayByWeekdays =\n          dir === 'next'\n            ? startDay + daysBetweenWeekdays\n            : startDay - daysBetweenWeekdays\n\n        // Make sure the day does not exceed the month boundaries.\n        if (allowedDayByWeekdays > daysInMonth || allowedDayByWeekdays < 1) {\n          allowedDayByWeekdays = undefined\n        }\n      }\n    }\n\n    if (allowedDayByDays !== undefined && allowedDayByWeekdays !== undefined) {\n      // If a day is found both via the days and the weekdays constraint, pick the day\n      // that is closer to start date.\n      return dir === 'next'\n        ? Math.min(allowedDayByDays, allowedDayByWeekdays)\n        : Math.max(allowedDayByDays, allowedDayByWeekdays)\n    }\n\n    if (allowedDayByDays !== undefined) {\n      return allowedDayByDays\n    }\n\n    if (allowedDayByWeekdays !== undefined) {\n      return allowedDayByWeekdays\n    }\n\n    return undefined\n  }\n\n  /** Gets the next date starting from the given start date or now. */\n  public getNextDate(startDate: Date = new Date()): Date {\n    const startDateElements = extractDateElements(startDate)\n    let minYear = startDateElements.year\n\n    let startIndexMonth = this.months.findIndex(\n      (x) => x >= startDateElements.month\n    )\n    if (startIndexMonth === -1) {\n      startIndexMonth = 0\n      minYear++\n    }\n\n    // We try every month within the next 5 years to make sure that we tried to\n    // find a matching date insidde a whole leap year.\n    const maxIterations = this.months.length * 5\n\n    for (let i = 0; i < maxIterations; i++) {\n      // Get the next year and month.\n      const year =\n        minYear + Math.floor((startIndexMonth + i) / this.months.length)\n      const month = this.months[(startIndexMonth + i) % this.months.length]\n      const isStartMonth =\n        year === startDateElements.year && month === startDateElements.month\n\n      // Find the next day.\n      let day = this.findAllowedDayInMonth(\n        'next',\n        year,\n        month,\n        isStartMonth ? startDateElements.day : 1\n      )\n      let isStartDay = isStartMonth && day === startDateElements.day\n\n      // If we found a day and it is the start day, try to find a valid time beginning from the start date time.\n      if (day !== undefined && isStartDay) {\n        const nextTime = this.findAllowedTime('next', startDateElements)\n        if (nextTime !== undefined) {\n          return new Date(\n            year,\n            month,\n            day,\n            nextTime.hour,\n            nextTime.minute,\n            nextTime.second\n          )\n        }\n\n        // If no valid time has been found for the start date, try the next day.\n        day = this.findAllowedDayInMonth('next', year, month, day + 1)\n        isStartDay = false\n      }\n\n      // If we found a next day and it is not the start day, just use the next day with the first allowed values\n      // for hours, minutes and seconds.\n      if (day !== undefined && !isStartDay) {\n        return new Date(\n          year,\n          month,\n          day,\n          this.hours[0],\n          this.minutes[0],\n          this.seconds[0]\n        )\n      }\n\n      // No allowed day has been found for this month. Continue to search in next month.\n    }\n\n    throw new Error('No valid next date was found.')\n  }\n\n  /** Gets the specified amount of future dates starting from the given start date or now. */\n  public getNextDates(amount: number, startDate?: Date): Date[] {\n    const dates = []\n    let nextDate\n\n    for (let i = 0; i < amount; i++) {\n      nextDate = this.getNextDate(nextDate ?? startDate)\n      dates.push(nextDate)\n    }\n\n    return dates\n  }\n\n  /**\n   * Get an ES6 compatible iterator which iterates over the next dates starting from startDate or now.\n   * The iterator runs until the optional endDate is reached or forever.\n   */\n  public *getNextDatesIterator(\n    startDate?: Date,\n    endDate?: Date\n  ): Generator<Date, undefined, undefined> {\n    let nextDate\n\n    while (true) {\n      nextDate = this.getNextDate(startDate)\n      startDate = nextDate\n\n      if (endDate && endDate.getTime() < nextDate.getTime()) {\n        return\n      }\n\n      yield nextDate\n    }\n  }\n\n  /** Gets the previous date starting from the given start date or now. */\n  public getPrevDate(startDate: Date = new Date()): Date {\n    const startDateElements = extractDateElements(startDate)\n    let maxYear = startDateElements.year\n\n    let startIndexMonth = this.reversed.months.findIndex(\n      (x) => x <= startDateElements.month\n    )\n    if (startIndexMonth === -1) {\n      startIndexMonth = 0\n      maxYear--\n    }\n\n    // We try every month within the past 5 years to make sure that we tried to\n    // find a matching date insidde a whole leap year.\n    const maxIterations = this.reversed.months.length * 5\n\n    for (let i = 0; i < maxIterations; i++) {\n      // Get the next year and month.\n      const year =\n        maxYear -\n        Math.floor((startIndexMonth + i) / this.reversed.months.length)\n      const month = this.reversed.months[\n        (startIndexMonth + i) % this.reversed.months.length\n      ]\n      const isStartMonth =\n        year === startDateElements.year && month === startDateElements.month\n\n      // Find the previous day.\n      let day = this.findAllowedDayInMonth(\n        'prev',\n        year,\n        month,\n        isStartMonth ? startDateElements.day : 31\n      )\n      let isStartDay = isStartMonth && day === startDateElements.day\n\n      // If we found a day and it is the start day, try to find a valid time beginning from the start date time.\n      if (day !== undefined && isStartDay) {\n        const prevTime = this.findAllowedTime('prev', startDateElements)\n        if (prevTime !== undefined) {\n          return new Date(\n            year,\n            month,\n            day,\n            prevTime.hour,\n            prevTime.minute,\n            prevTime.second\n          )\n        }\n\n        // If no valid time has been found for the start date, try the previous day.\n        if (day > 1) {\n          day = this.findAllowedDayInMonth('prev', year, month, day - 1)\n          isStartDay = false\n        }\n      }\n\n      // If we found a previous day and it is not the start day, just use the previous day with the first allowed values\n      // for hours, minutes and seconds (which will be the latest time due to using the reversed array).\n      if (day !== undefined && !isStartDay) {\n        return new Date(\n          year,\n          month,\n          day,\n          this.reversed.hours[0],\n          this.reversed.minutes[0],\n          this.reversed.seconds[0]\n        )\n      }\n\n      // No allowed day has been found for this month. Continue to search in previous month.\n    }\n\n    throw new Error('No valid previous date was found.')\n  }\n\n  /** Gets the specified amount of previous dates starting from the given start date or now. */\n  public getPrevDates(amount: number, startDate?: Date): Date[] {\n    const dates = []\n    let prevDate\n\n    for (let i = 0; i < amount; i++) {\n      prevDate = this.getPrevDate(prevDate ?? startDate)\n      dates.push(prevDate)\n    }\n\n    return dates\n  }\n\n  /**\n   * Get an ES6 compatible iterator which iterates over the previous dates starting from startDate or now.\n   * The iterator runs until the optional endDate is reached or forever.\n   */\n  public *getPrevDatesIterator(\n    startDate?: Date,\n    endDate?: Date\n  ): Generator<Date, undefined, undefined> {\n    let prevDate\n\n    while (true) {\n      prevDate = this.getPrevDate(startDate)\n      startDate = prevDate\n\n      if (endDate && endDate.getTime() > prevDate.getTime()) {\n        return\n      }\n\n      yield prevDate\n    }\n  }\n\n  /** Returns true when there is a cron date at the given date. */\n  public matchDate(date: Date): boolean {\n    const { second, minute, hour, day, month, weekday } = extractDateElements(\n      date\n    )\n\n    return (\n      this.seconds.indexOf(second) !== -1 &&\n      this.minutes.indexOf(minute) !== -1 &&\n      this.hours.indexOf(hour) !== -1 &&\n      this.months.indexOf(month) !== -1 &&\n      (this.days.indexOf(day) !== -1 || this.weekdays.indexOf(weekday) !== -1)\n    )\n  }\n}\n", "import { Cron } from './cron'\n\ninterface IConstraint {\n  min: number\n  max: number\n  aliases?: Record<string, string>\n}\n\nconst secondConstraint: IConstraint = {\n  min: 0,\n  max: 59,\n}\n\nconst minuteConstraint: IConstraint = {\n  min: 0,\n  max: 59,\n}\n\nconst hourConstraint: IConstraint = {\n  min: 0,\n  max: 23,\n}\n\nconst dayConstraint: IConstraint = {\n  min: 1,\n  max: 31,\n}\n\nconst monthConstraint: IConstraint = {\n  min: 1,\n  max: 12,\n  aliases: {\n    jan: '1',\n    feb: '2',\n    mar: '3',\n    apr: '4',\n    may: '5',\n    jun: '6',\n    jul: '7',\n    aug: '8',\n    sep: '9',\n    oct: '10',\n    nov: '11',\n    dec: '12',\n  },\n}\n\nconst weekdayConstraint: IConstraint = {\n  min: 0,\n  max: 6,\n  aliases: {\n    '7': '0',\n    'sun': '0',\n    'mon': '1',\n    'tue': '2',\n    'wed': '3',\n    'thu': '4',\n    'fri': '5',\n    'sat': '6',\n  },\n}\n\nconst timeNicknames: Record<string, string | undefined> = {\n  '@yearly': '0 0 1 1 *',\n  '@annually': '0 0 1 1 *',\n  '@monthly': '0 0 1 1 *',\n  '@weekly': '0 0 * * 0',\n  '@daily': '0 0 * * *',\n  '@hourly': '0 * * * *',\n  '@minutely': '* * * * *',\n}\n\nfunction parseElement(element: string, constraint: IConstraint): Set<number> {\n  const result = new Set<number>()\n\n  // If returned set of numbers is empty, the scheduler class interpretes the emtpy set of numbers as all valid values of the constraint\n  if (element === '*') {\n    for (let i = constraint.min; i <= constraint.max; i = i + 1) {\n      result.add(i)\n    }\n\n    return result\n  }\n\n  // If the element is a list, parse each element in the list.\n  const listElements = element.split(',')\n  if (listElements.length > 1) {\n    listElements.forEach((listElement) => {\n      const parsedListElement = parseElement(listElement, constraint)\n      parsedListElement.forEach((x) => result.add(x))\n    })\n\n    return result\n  }\n\n  // Helper function to parse a single element, which includes checking for alias, valid number and constraint min and max.\n  const parseSingleElement = (singleElement: string): number => {\n    singleElement =\n      constraint.aliases?.[singleElement.toLowerCase()] ?? singleElement\n    const parsedElement = parseInt(singleElement, 10)\n\n    if (Number.isNaN(parsedElement)) {\n      throw new Error(`Failed to parse ${element}: ${singleElement} is NaN.`)\n    }\n\n    if (parsedElement < constraint.min || parsedElement > constraint.max) {\n      throw new Error(\n        `Failed to parse ${element}: ${singleElement} is outside of constraint range of ${constraint.min} - ${constraint.max}.`\n      )\n    }\n\n    return parsedElement\n  }\n\n  // Detect if the element is a range.\n  // eslint-disable-next-line security/detect-unsafe-regex\n  const rangeSegments = /^((([0-9a-zA-Z]+)-([0-9a-zA-Z]+))|\\*)(\\/([0-9]+))?$/.exec(\n    element\n  )\n\n  // If not, it must be a single element.\n  if (rangeSegments === null) {\n    result.add(parseSingleElement(element))\n    return result\n  }\n\n  // If it is a range, get start and end of the range.\n  const parsedStart =\n    rangeSegments[1] === '*'\n      ? constraint.min\n      : parseSingleElement(rangeSegments[3])\n\n  const parsedEnd =\n    rangeSegments[1] === '*'\n      ? constraint.max\n      : parseSingleElement(rangeSegments[4])\n\n  if (parsedStart >= parsedEnd - 1) {\n    throw new Error(\n      `Failed to parse ${element}: Invalid range (start: ${parsedStart}, end: ${parsedEnd}).`\n    )\n  }\n\n  // Check whether there is a custom step defined for the range, defaulting to 1.\n  const step = rangeSegments[6] as string | undefined\n  let parsedStep = 1\n\n  if (step !== undefined) {\n    parsedStep = parseInt(step, 10)\n    if (Number.isNaN(parsedStep)) {\n      throw new Error(`Failed to parse step: ${step} is NaN.`)\n    } else if (parsedStep < 1) {\n      throw new Error(\n        `Failed to parse step: Expected ${step} to be greater than 0.`\n      )\n    }\n  }\n\n  // Go from start to end of the range by the given steps.\n  for (let i = parsedStart; i <= parsedEnd; i = i + parsedStep) {\n    result.add(i)\n  }\n\n  return result\n}\n\n/** Parses a cron expression into a Cron instance. */\nexport function parseCronExpression(cronExpression: string): Cron {\n  if (typeof cronExpression !== 'string') {\n    throw new TypeError('Invalid cron expression: must be of type string.')\n  }\n\n  // Convert time nicknames.\n  cronExpression = timeNicknames[cronExpression.toLowerCase()] ?? cronExpression\n\n  const elements = cronExpression.split(' ')\n  if (elements.length < 5 || elements.length > 6) {\n    throw new Error('Invalid cron expression: expected 5 or 6 elements.')\n  }\n\n  const rawSeconds = elements.length === 6 ? elements[0] : '0'\n  const rawMinutes = elements.length === 6 ? elements[1] : elements[0]\n  const rawHours = elements.length === 6 ? elements[2] : elements[1]\n  const rawDays = elements.length === 6 ? elements[3] : elements[2]\n  const rawMonths = elements.length === 6 ? elements[4] : elements[3]\n  const rawWeekdays = elements.length === 6 ? elements[5] : elements[4]\n\n  return new Cron({\n    seconds: parseElement(rawSeconds, secondConstraint),\n    minutes: parseElement(rawMinutes, minuteConstraint),\n    hours: parseElement(rawHours, hourConstraint),\n    days: parseElement(rawDays, dayConstraint),\n    // months in cron are indexed by 1, but Cron expects indexes by 0, so we need to reduce all set values by one.\n    months: new Set(\n      Array.from(parseElement(rawMonths, monthConstraint)).map((x) => x - 1)\n    ),\n    weekdays: parseElement(rawWeekdays, weekdayConstraint),\n  })\n}\n"],
  "mappings": "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",
  "names": []
}
